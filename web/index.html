<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    <!-- å…è®¸ Worker å’Œ Blobï¼Œè§£å†³ HLS åœ¨éƒ¨åˆ†æœåŠ¡å™¨ç¯å¢ƒä¸‹çš„è·¨åŸŸ/CSP é—®é¢˜ -->
    <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline' 'unsafe-eval'; script-src * 'unsafe-inline' 'unsafe-eval'; connect-src * 'unsafe-inline'; img-src * data: blob: 'unsafe-inline'; frame-src *; style-src * 'unsafe-inline'; worker-src * blob:; media-src * blob: data:;">
    <title>è¤ç«è™«Firefly</title>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@900&display=swap" rel="stylesheet">
    <!-- Tailwind CSSï¼ˆæ ·å¼æ¡†æ¶ï¼‰ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- HLS.jsï¼ˆm3u8 æ’­æ”¾ï¼‰ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hls.js/1.5.15/hls.min.js"></script>
    <!-- Fuse.jsï¼ˆæ¨¡ç³Šæœç´¢ï¼‰ -->
    <script src="https://unpkg.com/fuse.js@6.6.2/dist/fuse.min.js"></script>
    <!-- Vue.js 3ï¼ˆå‰ç«¯æ¡†æ¶ï¼‰ -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <style>
        :root {
            --primary-blue: #7ab8ff;
            --primary-blue-2: #6ee7ff;
            --bg-fallback: #0b1020;
            --text-main: rgba(255, 255, 255, 0.92);
            --text-gray: rgba(255, 255, 255, 0.65);
            --panel-bg: rgba(16, 20, 35, 0.52);
            --panel-bg-2: rgba(255, 255, 255, 0.08);
            --panel-border: rgba(255, 255, 255, 0.14);
        }
        body {
            font-family: "Microsoft YaHei", Arial, Helvetica, sans-serif;
            color: var(--text-main);
            font-size: 14px;
            background-color: var(--bg-fallback);
            background-image: radial-gradient(1200px 800px at 20% 10%, rgba(122, 184, 255, 0.22), rgba(0,0,0,0)), radial-gradient(900px 700px at 80% 30%, rgba(110, 231, 255, 0.18), rgba(0,0,0,0));
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
        }
        body[data-bg="back1"] {
            background-image: url('back1.png'), radial-gradient(1200px 800px at 20% 10%, rgba(122, 184, 255, 0.18), rgba(0,0,0,0)), radial-gradient(900px 700px at 80% 30%, rgba(110, 231, 255, 0.14), rgba(0,0,0,0));
        }
        body[data-bg="back2"] {
            background-image: url('back2.png'), radial-gradient(1200px 800px at 20% 10%, rgba(122, 184, 255, 0.18), rgba(0,0,0,0)), radial-gradient(900px 700px at 80% 30%, rgba(110, 231, 255, 0.14), rgba(0,0,0,0));
        }
        body::before {
            content: "";
            position: fixed;
            inset: 0;
            pointer-events: none;
            background: linear-gradient(180deg, rgba(8, 12, 24, 0.60) 0%, rgba(8, 12, 24, 0.35) 45%, rgba(8, 12, 24, 0.75) 100%);
        }
        body::after {
            content: "";
            position: fixed;
            inset: 0;
            pointer-events: none;
            background: radial-gradient(800px 500px at 50% 0%, rgba(255,255,255,0.08), rgba(0,0,0,0));
            mix-blend-mode: screen;
        }
        #app {
            position: relative;
            z-index: 0;
        }
        .glass-panel {
            background: linear-gradient(180deg, var(--panel-bg), rgba(16, 20, 35, 0.38));
            border: 1px solid var(--panel-border);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }
        /* ç´§å‡‘å¤´éƒ¨ */
        .yx-header {
            background: linear-gradient(90deg, rgba(16, 20, 35, 0.62), rgba(16, 20, 35, 0.46));
            border-bottom: 1px solid rgba(255,255,255,0.12);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
        }
        .nav-item {
            position: relative;
            transition: all 0.2s;
        }
        .nav-item:hover, .nav-item.active {
            background-color: rgba(255,255,255,0.12);
        }
        .nav-item.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, var(--primary-blue), var(--primary-blue-2));
        }
        
        /* ç´§å‡‘ç½‘æ ¼ */
        .anime-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); /* æ›´ç´§å‡‘çš„å¡ç‰‡å®½åº¦ */
            gap: 15px; /* æ›´å°çš„é—´è· */
        }
        .anime-item {
            background: rgba(16, 20, 35, 0.52);
            border: 1px solid var(--panel-border);
            border-radius: 4px;
            transition: box-shadow 0.2s;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        .anime-item:hover {
            box-shadow: 0 10px 30px rgba(0,0,0,0.35);
            border-color: rgba(122, 184, 255, 0.55);
        }
        .cover-wrapper {
            position: relative;
            padding-top: 140%; /* 1.4 çš„çºµæ¨ªæ¯” */
            overflow: hidden;
        }
        .cover-img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .anime-info {
            padding: 8px;
        }
        .anime-title {
            font-size: 14px;
            line-height: 20px;
            height: 40px; /* æœ€å¤šä¸¤è¡Œ */
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            margin-bottom: 4px;
        }
        .anime-status {
            font-size: 12px;
            color: var(--text-gray);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* è¯¦æƒ…å¼¹çª—ï¼ˆç´§å‡‘æ ·å¼ï¼‰ */
        .modal-overlay {
            background-color: rgba(0,0,0,0.7);
        }
        .modal-content {
            border-radius: 4px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }
        .episode-btn {
            border: 1px solid rgba(255,255,255,0.16);
            background: rgba(16, 20, 35, 0.55);
            color: rgba(255,255,255,0.85);
            font-size: 12px;
            padding: 6px 10px;
            border-radius: 2px;
        }
        .episode-btn:hover {
            border-color: rgba(110, 231, 255, 0.55);
            color: rgba(110, 231, 255, 0.95);
        }
        .episode-btn.active {
            background: linear-gradient(90deg, rgba(122, 184, 255, 0.90), rgba(110, 231, 255, 0.85));
            color: rgba(16, 20, 35, 0.95);
            border-color: rgba(110, 231, 255, 0.55);
        }

        /* æ»šåŠ¨æ¡ */
        .no-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.20);
            border-radius: 4px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.06);
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in {
            animation: fadeIn 0.2s ease-out;
        }
        [v-cloak] { display: none; }
    </style>
</head>
<body>
    <div id="app" v-cloak class="min-h-screen flex flex-col">
        <!-- å¤´éƒ¨ -->
        <header class="yx-header text-white sticky top-0 z-50">
            <div class="container mx-auto px-2 md:px-4">
                <!-- é¡¶éƒ¨ï¼šLogo ä¸æœç´¢ -->
                <div class="flex justify-between items-center h-16 border-b border-white/15">
                    <div class="flex items-center gap-4">
                        <!-- Logo å ä½ -->
                        <div class="text-2xl font-bold italic tracking-tighter flex items-center">
                            <span class="bg-gradient-to-r from-cyan-400 via-blue-600 to-orange-400 text-white rounded px-2.5 py-0.5 mr-2 shadow-sm font-black tracking-normal" style="font-family: 'Orbitron', sans-serif;">Fire</span>
                            è¤ç«è™«Firefly
                        </div>
                    </div>
                    
                    <div class="flex items-center gap-2">
                        <div class="relative">
                            <input 
                                type="text" 
                                v-model="searchQuery"
                                @focus="showSuggestions = true"
                                @blur="setTimeout(() => showSuggestions = false, 200)"
                                placeholder="è¯·è¾“å…¥æ‚¨æƒ³è¦æœç´¢çš„åŠ¨ç”»..." 
                                class="w-48 md:w-64 pl-3 pr-10 py-1.5 rounded-sm text-gray-900 text-sm focus:outline-none focus:ring-2 focus:ring-blue-300"
                            >
                            <button class="absolute right-0 top-0 h-full px-3 text-gray-900 font-bold bg-white rounded-r-sm hover:bg-gray-100 transition-colors">
                                æœ
                            </button>
                            <!-- æœç´¢å»ºè®® -->
                            <ul v-if="showSuggestions && searchSuggestions.length > 0" class="absolute z-50 w-full mt-1 bg-white rounded-sm shadow-lg max-h-60 overflow-y-auto text-gray-900 text-sm animate-fade-in">
                                <li v-for="(item, index) in searchSuggestions" :key="index"
                                    @click="selectSuggestion(item)"
                                    class="px-3 py-2 cursor-pointer hover:bg-blue-50 transition-colors border-b border-gray-100 last:border-0 text-left">
                                    <div class="font-bold truncate text-gray-800">{{ item.ç‰‡å }}</div>
                                    <div class="text-xs text-gray-500 truncate flex justify-between">
                                        <span>{{ item.å¹´ä»£ }}</span>
                                        <span>{{ item.ç±»å‹ }}</span>
                                    </div>
                                </li>
                            </ul>
                        </div>
                    </div>
                </div>

                <!-- åº•éƒ¨ï¼šå¯¼èˆªï¼ˆå­£åº¦ï¼‰ -->
                <nav class="h-10 flex items-center overflow-visible z-40">
                    <a href="#" 
                       @click.prevent="goHome()" 
                       class="nav-item px-4 h-full flex items-center text-sm font-medium"
                       :class="{ 'active': currentActiveNav === 'home' }">
                        é¦–é¡µ/ç­›é€‰
                    </a>

                    <a href="#" 
                       @click.prevent="currentStatus = 'ongoing'; currentSeason = 'all'; currentGenre = 'all'; currentView = 'list'" 
                       class="nav-item px-4 h-full flex items-center text-sm font-medium"
                       :class="{ 'active': currentActiveNav === 'ongoing' }">
                        è¿è½½ç•ªå‰§
                    </a>

                    <a href="#" 
                       @click.prevent="currentStatus = 'completed'; currentSeason = 'all'; currentGenre = 'all'; currentView = 'list'" 
                       class="nav-item px-4 h-full flex items-center text-sm font-medium"
                       :class="{ 'active': currentActiveNav === 'completed' }">
                        å®Œç»“ç•ªå‰§
                    </a>

                    <a href="#" 
                       @click.prevent="filterSeason(String(currentYear)); currentStatus = 'all'; currentGenre = 'all'; currentView = 'list'" 
                       class="nav-item px-4 h-full flex items-center text-sm font-medium"
                       :class="{ 'active': currentActiveNav === 'currentYear' }">
                        {{ currentYear }}å¹´æ–°ç•ª
                    </a>

                    <a href="#" 
                       @click.prevent="filterSeason(String(prevYear)); currentStatus = 'all'; currentGenre = 'all'; currentView = 'list'" 
                       class="nav-item px-4 h-full flex items-center text-sm font-medium"
                       :class="{ 'active': currentActiveNav === 'prevYear' }">
                        {{ prevYear }}å¹´æ–°ç•ª
                    </a>

                    <a href="#" 
                       @click.prevent="currentView = 'archive'" 
                       class="nav-item px-4 h-full flex items-center text-sm font-medium"
                       :class="{ 'active': currentActiveNav === 'archive' }">
                        æ–°ç•ªä¸“é¢˜
                    </a>
                    <a href="theater_version.html" 
                       class="nav-item px-4 h-full flex items-center text-sm font-medium">
                        å‰§åœºç‰ˆ
                    </a>
                </nav>
            </div>
        </header>

        <!-- ä¸»å†…å®¹ -->
        <main class="container mx-auto px-2 md:px-4 py-4 flex-1">
            <!-- é¢åŒ…å±‘ / çŠ¶æ€æ  -->
            <div class="glass-panel p-3 mb-4 rounded-sm flex justify-between items-center text-xs text-white/70 shadow-[0_10px_30px_rgba(0,0,0,0.25)]">
                <div>
                    å½“å‰ä½ç½®ï¼š<span class="text-cyan-200">é¦–é¡µ</span> 
                    <span v-if="currentStatus !== 'all'"> &gt; {{ currentStatus === 'ongoing' ? 'è¿è½½ç•ªå‰§' : 'å®Œç»“ç•ªå‰§' }}</span>
                    <span v-if="currentGenre !== 'all'"> &gt; {{ currentGenre }}</span>
                    <span v-if="currentSeason !== 'all'"> &gt; {{ getSeasonLabel(currentSeason) }}</span>
                </div>
                <div>
                    å…±æ‰¾åˆ° <span class="text-cyan-200 font-bold">{{ filteredAnimeList.length }}</span> éƒ¨ç›¸å…³åŠ¨æ¼«
                </div>
            </div>

            <div class="flex flex-col lg:flex-row gap-4 items-start">
                <div class="flex-1 min-w-0">

            <!-- å­å¯¼èˆªï¼šæŒ‰å¹´ä»½é€‰æ‹©å­£åº¦ -->
            <div v-if="!loading && currentView === 'list'" class="glass-panel p-4 mb-4 rounded-sm text-sm shadow-[0_10px_30px_rgba(0,0,0,0.25)]">
                <!-- çŠ¶æ€è¡Œ -->
                <div class="flex items-center gap-3 mb-3 border-b border-white/10 pb-3">
                    <span class="text-cyan-200 font-bold shrink-0 text-xs uppercase tracking-wider">çŠ¶æ€</span>
                    <div class="flex items-center gap-2 overflow-x-auto whitespace-nowrap no-scrollbar flex-1">
                        <button
                            @click="currentStatus = 'all'"
                            class="px-4 py-1.5 rounded-full text-xs font-medium transition-all duration-200 border"
                            :class="currentStatus === 'all' ? 'bg-cyan-500/20 text-cyan-200 border-cyan-400/50 shadow-[0_0_10px_rgba(103,232,249,0.2)]' : 'bg-white/5 border-white/10 text-white/60 hover:bg-white/10 hover:text-white/90 hover:border-white/30'"
                        >
                            å…¨éƒ¨
                        </button>
                        <button
                            @click="currentStatus = 'ongoing'"
                            class="px-4 py-1.5 rounded-full text-xs font-medium transition-all duration-200 border"
                            :class="currentStatus === 'ongoing' ? 'bg-cyan-500/20 text-cyan-200 border-cyan-400/50 shadow-[0_0_10px_rgba(103,232,249,0.2)]' : 'bg-white/5 border-white/10 text-white/60 hover:bg-white/10 hover:text-white/90 hover:border-white/30'"
                        >
                            è¿è½½
                        </button>
                        <button
                            @click="currentStatus = 'completed'"
                            class="px-4 py-1.5 rounded-full text-xs font-medium transition-all duration-200 border"
                            :class="currentStatus === 'completed' ? 'bg-cyan-500/20 text-cyan-200 border-cyan-400/50 shadow-[0_0_10px_rgba(103,232,249,0.2)]' : 'bg-white/5 border-white/10 text-white/60 hover:bg-white/10 hover:text-white/90 hover:border-white/30'"
                        >
                            å®Œç»“
                        </button>
                    </div>
                </div>
                <!-- ç±»å‹è¡Œ -->
                <div class="flex items-start gap-3 mb-3 border-b border-white/10 pb-3">
                    <span class="text-cyan-200 font-bold shrink-0 text-xs uppercase tracking-wider">ç±»å‹</span>
                    <div class="flex-1 flex items-start gap-2 min-w-0">
                        <div class="flex-1 flex flex-wrap gap-2 min-w-0">
                            <button
                                @click="currentGenre = 'all'"
                                class="px-4 py-1.5 rounded-full text-xs font-medium transition-all duration-200 border"
                                :class="currentGenre === 'all' ? 'bg-cyan-500/20 text-cyan-200 border-cyan-400/50 shadow-[0_0_10px_rgba(103,232,249,0.2)]' : 'bg-white/5 border-white/10 text-white/60 hover:bg-white/10 hover:text-white/90 hover:border-white/30'"
                            >
                                å…¨éƒ¨
                            </button>
                            <button
                                v-for="genre in displayedGenres"
                                :key="genre"
                                @click="currentGenre = genre"
                                class="px-4 py-1.5 rounded-full text-xs font-medium transition-all duration-200 border"
                                :class="currentGenre === genre ? 'bg-cyan-500/20 text-cyan-200 border-cyan-400/50 shadow-[0_0_10px_rgba(103,232,249,0.2)]' : 'bg-white/5 border-white/10 text-white/60 hover:bg-white/10 hover:text-white/90 hover:border-white/30'"
                            >
                                {{ genre }}
                            </button>
                        </div>
                        <button
                            v-if="allGenres.length > genrePreviewCount"
                            @click="genreExpanded = !genreExpanded"
                            class="px-4 py-1.5 rounded-full text-xs font-medium transition-all duration-200 border bg-white/5 border-white/10 text-white/70 hover:bg-white/10 hover:text-white/90 hover:border-white/30 shrink-0"
                        >
                            <span class="inline-flex items-center gap-1.5">
                                <span>{{ genreExpanded ? 'æ”¶èµ·' : 'å±•å¼€' }}</span>
                                <svg v-if="!genreExpanded" xmlns="http://www.w3.org/2000/svg" class="w-3.5 h-3.5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 0 1 1.06.02L10 11.168l3.71-3.938a.75.75 0 1 1 1.08 1.04l-4.24 4.5a.75.75 0 0 1-1.08 0l-4.24-4.5a.75.75 0 0 1 .02-1.06Z" clip-rule="evenodd" />
                                </svg>
                                <svg v-else xmlns="http://www.w3.org/2000/svg" class="w-3.5 h-3.5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M14.77 12.79a.75.75 0 0 1-1.06-.02L10 8.832l-3.71 3.938a.75.75 0 1 1-1.08-1.04l4.24-4.5a.75.75 0 0 1 1.08 0l4.24 4.5a.75.75 0 0 1-.02 1.06Z" clip-rule="evenodd" />
                                </svg>
                            </span>
                        </button>
                    </div>
                </div>
                <!-- å¹´ä»½è¡Œ -->
                <div class="flex items-start gap-3 mb-3 border-b border-white/10 pb-3">
                    <span class="text-cyan-200 font-bold shrink-0 text-xs uppercase tracking-wider">å¹´ä»½</span>
                    <div class="flex-1 flex items-start gap-2 min-w-0">
                        <div class="flex-1 flex flex-wrap gap-2 min-w-0">
                            <button
                                @click="setSeasonNavYear('all'); filterSeason('all')"
                                class="px-4 py-1.5 rounded-full text-xs font-medium transition-all duration-200 border"
                                :class="seasonNavYear === 'all' ? 'bg-cyan-500/20 text-cyan-200 border-cyan-400/50 shadow-[0_0_10px_rgba(103,232,249,0.2)]' : 'bg-white/5 border-white/10 text-white/60 hover:bg-white/10 hover:text-white/90 hover:border-white/30'"
                            >
                                å…¨éƒ¨
                            </button>
                            <button
                                v-for="year in displayedYears"
                                :key="year"
                                @click="setSeasonNavYear(year)"
                                class="px-4 py-1.5 rounded-full text-xs font-medium transition-all duration-200 border"
                                :class="seasonNavYear === year ? 'bg-cyan-500/20 text-cyan-200 border-cyan-400/50 shadow-[0_0_10px_rgba(103,232,249,0.2)]' : 'bg-white/5 border-white/10 text-white/60 hover:bg-white/10 hover:text-white/90 hover:border-white/30'"
                            >
                                {{ year }}
                            </button>
                        </div>
                        <button
                            v-if="seasonNavYears.length > yearPreviewCount"
                            @click="yearExpanded = !yearExpanded"
                            class="px-4 py-1.5 rounded-full text-xs font-medium transition-all duration-200 border bg-white/5 border-white/10 text-white/70 hover:bg-white/10 hover:text-white/90 hover:border-white/30 shrink-0"
                        >
                            <span class="inline-flex items-center gap-1.5">
                                <span>{{ yearExpanded ? 'æ”¶èµ·' : 'å±•å¼€' }}</span>
                                <svg v-if="!yearExpanded" xmlns="http://www.w3.org/2000/svg" class="w-3.5 h-3.5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 0 1 1.06.02L10 11.168l3.71-3.938a.75.75 0 1 1 1.08 1.04l-4.24 4.5a.75.75 0 0 1-1.08 0l-4.24-4.5a.75.75 0 0 1 .02-1.06Z" clip-rule="evenodd" />
                                </svg>
                                <svg v-else xmlns="http://www.w3.org/2000/svg" class="w-3.5 h-3.5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M14.77 12.79a.75.75 0 0 1-1.06-.02L10 8.832l-3.71 3.938a.75.75 0 1 1-1.08-1.04l4.24-4.5a.75.75 0 0 1 1.08 0l4.24 4.5a.75.75 0 0 1-.02 1.06Z" clip-rule="evenodd" />
                                </svg>
                            </span>
                        </button>
                    </div>
                </div>
                
                <!-- å­£åº¦è¡Œ -->
                <div class="flex items-center gap-3">
                    <span class="text-cyan-200 font-bold shrink-0 text-xs uppercase tracking-wider">å­£åº¦</span>
                    <div class="flex items-center gap-2 overflow-x-auto whitespace-nowrap no-scrollbar flex-1">
                        <button
                            @click="filterSeason(seasonNavYear)"
                            class="px-4 py-1.5 rounded-full text-xs font-medium transition-all duration-200 border"
                            :class="currentSeason === seasonNavYear ? 'bg-cyan-500/20 text-cyan-200 border-cyan-400/50 shadow-[0_0_10px_rgba(103,232,249,0.2)]' : 'bg-white/5 border-white/10 text-white/60 hover:bg-white/10 hover:text-white/90 hover:border-white/30'"
                        >
                            å…¨éƒ¨
                        </button>
                        <button
                            v-for="q in seasonNavQuarters"
                            :key="q.key"
                            :disabled="!q.enabled"
                            @click="filterSeason(q.key)"
                            class="px-4 py-1.5 rounded-full text-xs font-medium transition-all duration-200 border disabled:opacity-30 disabled:cursor-not-allowed"
                            :class="currentSeason === q.key ? 'bg-cyan-500/20 text-cyan-200 border-cyan-400/50 shadow-[0_0_10px_rgba(103,232,249,0.2)]' : 'bg-white/5 border-white/10 text-white/60 hover:bg-white/10 hover:text-white/90 hover:border-white/30'"
                        >
                            {{ q.label }}
                        </button>
                    </div>
                </div>
            </div>

            <!-- åŠ è½½ä¸­ -->
            <div v-if="loading" class="text-center py-20 text-white/70">
                <p>æ­£åœ¨åŠ è½½æ•°æ®...</p>
            </div>

            <!-- ç´¢å¼•è§†å›¾ -->
            <div v-else-if="currentView === 'archive'" class="animate-fade-in">
                <h2 class="text-2xl font-bold text-white mb-6 pl-2 border-l-4 border-cyan-300">æ–°ç•ªä¸“é¢˜</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                    <div v-for="group in groupedSeasons" :key="group.year" class="glass-panel p-5 rounded-lg hover:bg-white/5 transition-colors">
                        <div class="text-3xl font-bold text-white/20 mb-4">{{ group.year }}</div>
                        <div class="grid grid-cols-2 gap-3">
                            <button 
                                v-for="season in group.seasons" 
                                :key="season.key"
                                @click="filterSeason(season.key)"
                                class="px-3 py-2 text-sm text-center rounded bg-white/5 hover:bg-cyan-500/20 hover:text-cyan-200 border border-white/10 hover:border-cyan-500/30 transition-all"
                            >
                                {{ season.label }}
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- åŠ¨æ¼«åˆ—è¡¨ -->
            <div v-else>
                <div class="anime-grid">
                    <div 
                        v-for="(anime, index) in paginatedAnimeList" 
                        :key="index"
                        class="anime-item cursor-pointer group"
                        @click="openDetail(anime)"
                    >
                        <div class="cover-wrapper">
                            <img 
                                :src="anime.å°é¢ || 'https://via.placeholder.com/300x450?text=No+Cover'" 
                                class="cover-img group-hover:scale-105 transition-transform duration-300"
                                loading="lazy"
                            >
                            <div class="absolute bottom-0 right-0 bg-black/60 text-white text-xs px-1.5 py-0.5 rounded-tl-sm">
                                {{ anime.è±†ç“£ }}
                            </div>
                            <div class="absolute top-0 left-0 bg-gradient-to-r from-blue-400 to-cyan-300 text-slate-900 text-xs px-1.5 py-0.5 shadow-sm" v-if="isNew(anime.é¦–æ’­æ—¶é—´)">
                                æ–°
                            </div>
                        </div>
                        <div class="anime-info">
                            <h3 class="anime-title font-bold text-white/90 group-hover:text-cyan-200" :title="anime.ç‰‡å">{{ anime.ç‰‡å }}</h3>
                            <div class="flex justify-between items-center mt-1">
                                <span class="anime-status">{{ anime.çŠ¶æ€ || 'è¿è½½ä¸­' }}</span>
                                <span class="text-xs text-white/55">{{ anime.å¹´ä»£ }}</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- åˆ†é¡µæ§ä»¶ -->
                <div v-if="totalPages > 1" class="flex justify-center items-center mt-8 gap-2">
                    <button 
                        @click="changePage(currentPage - 1)" 
                        :disabled="currentPage === 1"
                        class="px-3 py-1 border border-white/15 rounded-sm text-sm text-white/80 hover:border-cyan-200 hover:text-cyan-200 disabled:opacity-50 disabled:cursor-not-allowed bg-white/10 backdrop-blur"
                    >
                        ä¸Šä¸€é¡µ
                    </button>
                    
                    <div class="flex gap-1">
                        <template v-for="page in totalPages" :key="page">
                            <button 
                                v-if="Math.abs(page - currentPage) < 3 || page === 1 || page === totalPages"
                                @click="changePage(page)"
                                class="px-3 py-1 border rounded-sm text-sm"
                                :class="currentPage === page ? 'bg-gradient-to-r from-blue-400 to-cyan-200 text-slate-900 border-white/0' : 'bg-white/10 border-white/15 text-white/80 hover:border-cyan-200 hover:text-cyan-200 backdrop-blur'"
                            >
                                {{ page }}
                            </button>
                            <span v-else-if="Math.abs(page - currentPage) === 3" class="px-1 text-white/50">...</span>
                        </template>
                    </div>

                    <button 
                        @click="changePage(currentPage + 1)" 
                        :disabled="currentPage === totalPages"
                        class="px-3 py-1 border border-white/15 rounded-sm text-sm text-white/80 hover:border-cyan-200 hover:text-cyan-200 disabled:opacity-50 disabled:cursor-not-allowed bg-white/10 backdrop-blur"
                    >
                        ä¸‹ä¸€é¡µ
                    </button>
                </div>
            </div>
                </div>
                <aside v-if="currentView === 'list'" class="w-full lg:w-80 xl:w-96 shrink-0 lg:sticky lg:top-24">
                    <div class="glass-panel p-4 rounded-sm text-sm shadow-[0_10px_30px_rgba(0,0,0,0.25)]">
                        <h2 class="text-lg font-bold text-white mb-3 pl-2 border-l-4 border-cyan-300">è¿½ç•ªæ—¥å†</h2>
                        <div class="grid grid-cols-4 gap-2 mb-3">
                            <button 
                                v-for="(day, index) in weekDays" 
                                :key="index"
                                @click="currentDayIndex = index"
                                class="px-2 py-1.5 rounded-full text-xs font-medium transition-all duration-200 border w-full"
                                :class="{ 'bg-cyan-500/20 text-cyan-200 border-cyan-400/50 shadow-[0_0_10px_rgba(103,232,249,0.2)]': index === currentDayIndex, 'bg-white/5 border-white/10 text-white/60 hover:bg-white/10 hover:text-white/90 hover:border-white/30': index !== currentDayIndex }"
                            >
                                {{ day }}
                            </button>
                        </div>
                        <div class="glass-panel p-3 rounded-sm bg-black/20">
                            <div class="text-sm font-bold text-cyan-200 mb-2 text-center border-b border-white/10 pb-2">
                                {{ weekDays[currentDayIndex] }} æ›´æ–°
                            </div>
                            <div class="space-y-2 max-h-[60vh] lg:max-h-[calc(100vh-15rem)] overflow-y-auto no-scrollbar pr-1">
                                <div 
                                    v-for="(item, idx) in currentDayAnime" 
                                    :key="idx"
                                    @click="handleCalendarClick(item.name)"
                                    class="px-3 py-2 rounded-sm border border-white/10 hover:border-cyan-400/50 hover:bg-cyan-500/10 transition-all duration-200 cursor-pointer flex justify-between items-center gap-3"
                                >
                                    <span class="text-white/90 font-medium truncate min-w-0 flex-1" :title="item.name">{{ item.name }}</span>
                                    <span class="text-cyan-200/80 text-[11px] bg-cyan-500/10 px-2 py-0.5 rounded border border-cyan-500/20 shrink-0">{{ item.time || 'æ—¶é—´æœªå®š' }}</span>
                                </div>
                                <div v-if="currentDayAnime.length === 0" class="text-center text-white/40 py-8 flex flex-col items-center">
                                    <span class="text-2xl mb-2">ğŸ˜´</span>
                                    <span>ä»Šæ—¥æš‚æ— æ›´æ–°</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </aside>
            </div>
        </main>

        <!-- é¡µè„š -->
        <footer class="glass-panel border-t border-white/10 py-6 mt-8 text-center text-xs text-white/70">
            <div class="container mx-auto">
                <p class="mb-2">æœ¬ç«™å†…å®¹å‡æ¥æºäºç½‘ç»œï¼Œä»…ä¾›å­¦ä¹ äº¤æµä½¿ç”¨</p>
                <p class="mb-2">ç‰¹åˆ«æ„Ÿè°¢èŒ…å°èµ„æºï¼Œæš´é£èµ„æºå’ŒHazxå¤§ä½¬çš„åˆ†äº«</p>
            </div>
        </footer>

        <!-- è¯¦æƒ…å¼¹çª—ï¼ˆç´§å‡‘ï¼‰ -->
        <div v-if="selectedAnime" class="fixed inset-0 z-[100] flex items-center justify-center p-2 md:p-4 modal-overlay backdrop-blur-sm" @click.self="closeDetail">
            <div class="glass-panel w-full max-w-6xl h-[85vh] flex flex-col md:flex-row overflow-hidden modal-content animate-fade-in relative">
                
                <!-- å…³é—­æŒ‰é’® -->
                <button @click="closeDetail" class="absolute top-2 right-2 z-50 bg-white/10 hover:bg-red-500 hover:text-white text-white/80 border border-white/10 rounded-full p-1.5 transition-colors backdrop-blur">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>

                <!-- å·¦ä¾§ï¼šä¿¡æ¯ -->
                <div class="w-full md:w-80 bg-white/5 p-4 overflow-y-auto border-r border-white/10 shrink-0">
                    <div class="aspect-[2/3] w-48 mx-auto md:w-full mb-4 shadow-md rounded-sm overflow-hidden">
                        <img :src="selectedAnime.å°é¢" class="w-full h-full object-cover">
                    </div>
                    <h2 class="text-lg font-bold text-white/90 mb-3 text-center">{{ selectedAnime.ç‰‡å }}</h2>
                    
                    <div class="space-y-2 text-xs text-white/70 border-t border-white/10 pt-3">
                        <p><span class="text-white/50">åˆ«åï¼š</span>{{ selectedAnime.åˆ«å }}</p>
                        <p><span class="text-white/50">é¦–æ’­ï¼š</span>{{ selectedAnime.é¦–æ’­æ—¶é—´ || selectedAnime.å¹´ä»£ }}</p>
                        <p><span class="text-white/50">åœ°åŒºï¼š</span>{{ selectedAnime.åœ°åŒº }}</p>
                        <p><span class="text-white/50">ç±»å‹ï¼š</span>{{ selectedAnime.ç±»å‹ }}</p>
                        <p><span class="text-white/50">å¯¼æ¼”ï¼š</span>{{ selectedAnime.å¯¼æ¼” }}</p>
                        <p><span class="text-white/50">ä¸»æ¼”ï¼š</span>{{ selectedAnime.æ¼”å‘˜ }}</p>
                    </div>
                    <div class="mt-4 text-xs text-white/70 leading-relaxed border-t border-white/10 pt-3">
                        <span class="font-bold text-white/80 block mb-1">ç®€ä»‹ï¼š</span>
                        {{ selectedAnime.å‰§æƒ…ä»‹ç» }}
                    </div>
                </div>

                <!-- å³ä¾§ï¼šæ’­æ”¾å™¨ä¸åˆ—è¡¨ -->
                <div class="flex-1 flex flex-col bg-transparent min-w-0">
                    <!-- æ’­æ”¾å™¨åŒºåŸŸ -->
                    <div class="bg-black w-full aspect-video md:h-[60%] flex items-center justify-center relative group">
                        <video id="videoPlayer" class="w-full h-full" controls autoplay preload="auto" playsinline webkit-playsinline></video>
                        <div v-if="!currentEpisodeUrl" class="absolute text-white/50 text-sm pointer-events-none">
                            è¯·é€‰æ‹©ä¸‹æ–¹é›†æ•°å¼€å§‹æ’­æ”¾
                        </div>
                    </div>

                    <!-- é€‰é¡¹å¡ -->
                    <div class="flex border-b border-white/10">
                        <button 
                            @click="activeTab = 'episodes'" 
                            class="flex-1 py-3 text-sm font-bold text-center transition-colors relative"
                            :class="activeTab === 'episodes' ? 'text-cyan-200' : 'text-white/70 hover:bg-white/5'"
                        >
                            æ’­æ”¾åˆ—è¡¨
                            <span v-if="activeTab === 'episodes'" class="absolute bottom-0 left-0 w-full h-0.5 bg-gradient-to-r from-blue-400 to-cyan-200"></span>
                        </button>
                        <button 
                            @click="activeTab = 'related'" 
                            class="flex-1 py-3 text-sm font-bold text-center transition-colors relative"
                            :class="activeTab === 'related' ? 'text-cyan-200' : 'text-white/70 hover:bg-white/5'"
                        >
                            çŒœä½ å–œæ¬¢
                            <span v-if="activeTab === 'related'" class="absolute bottom-0 left-0 w-full h-0.5 bg-gradient-to-r from-blue-400 to-cyan-200"></span>
                        </button>
                    </div>

                    <!-- å†…å®¹åŒºåŸŸ -->
                    <div class="flex-1 overflow-y-auto bg-transparent relative">
                        <!-- æ’­æ”¾åˆ—è¡¨ -->
                        <div v-if="activeTab === 'episodes'" class="p-4 absolute inset-0 overflow-y-auto">
                            <div v-if="selectedAnime.æ’­æ”¾åœ°å€ && selectedAnime.æ’­æ”¾åœ°å€.length > 0">
                                <div v-for="(source, sIndex) in selectedAnime.æ’­æ”¾åœ°å€" :key="sIndex" class="mb-4">
                                    <div class="flex items-center mb-2">
                                        <span class="bg-white/10 text-cyan-200 text-xs px-2 py-0.5 rounded-sm mr-2 border border-white/10">æ¥æº</span>
                                        <h4 class="text-sm font-bold text-white/85">{{ source.source || 'é»˜è®¤æº' }}</h4>
                                    </div>
                                    <div class="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 lg:grid-cols-10 gap-2">
                                        <button 
                                            v-for="(ep, epIndex) in source.episodes" 
                                            :key="epIndex"
                                            class="episode-btn truncate"
                                            :class="{ 'active': currentEpisodeUrl === ep.url }"
                                            @click="playEpisode(ep.url, ep.name)"
                                            :title="ep.name"
                                        >
                                            {{ ep.name }}
                                        </button>
                                    </div>
                                </div>
                            </div>
                            <div v-else class="flex flex-col items-center justify-center h-full text-white/55 text-sm">
                                <span class="text-3xl mb-2">ğŸ˜•</span>
                                æš‚æ— æ’­æ”¾èµ„æº
                            </div>
                        </div>

                        <!-- çŒœä½ å–œæ¬¢ -->
                        <div v-if="activeTab === 'related'" class="p-4 absolute inset-0 overflow-y-auto">
                            <div class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-3">
                                <div 
                                    v-for="(anime, idx) in relatedList" 
                                    :key="idx" 
                                    class="cursor-pointer group"
                                    @click="openDetail(anime)"
                                >
                                    <div class="relative aspect-[2/3] overflow-hidden rounded-sm mb-1">
                                        <img :src="anime.å°é¢" class="w-full h-full object-cover group-hover:scale-105 transition-transform">
                                        <div class="absolute bottom-0 right-0 bg-black/60 text-white text-[10px] px-1">
                                            {{ anime.è±†ç“£ }}
                                        </div>
                                    </div>
                                    <h4 class="text-xs text-white/80 truncate group-hover:text-cyan-200">{{ anime.ç‰‡å }}</h4>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        (function () {
            const bg = Math.random() < 0.5 ? 'back1' : 'back2';
            document.body.dataset.bg = bg;
        })();
        const { createApp, ref, computed, onMounted, onUnmounted, nextTick, watch } = Vue;

        createApp({
            setup() {
                const animeList = ref([]);
                const movieList = ref([]);

                const searchPool = computed(() => {
                    const items = [...(animeList.value || []), ...(movieList.value || [])];
                    const map = new Map();
                    for (const item of items) {
                        if (!item) continue;
                        const key = item.è±†ç“£ID || item.detail_url || `${item.ç‰‡å || ''}__${item.å¹´ä»£ || ''}`;
                        if (!map.has(key)) map.set(key, item);
                    }
                    return Array.from(map.values());
                });
                
                // è¿½ç•ªæ—¥å†æ•°æ®
                const calendarData = ref([]);

                const currentDayAnime = computed(() => {
                    const day = weekDays[currentDayIndex.value];
                    if (!calendarData.value) return [];
                    return calendarData.value
                        .filter(item => item.day === day)
                        .sort((a, b) => {
                             if (!a.time) return 1;
                             if (!b.time) return -1;
                             return a.time.localeCompare(b.time);
                        });
                });

                const handleCalendarClick = (name) => {
                    if (!name) return;
                    const pool = searchPool.value || [];
                    if (pool.length === 0) {
                        searchQuery.value = name;
                        window.scrollTo({ top: 0, behavior: 'smooth' });
                        return;
                    }

                    const normalizeBasic = (str) => {
                        if (!str) return '';
                        return String(str)
                            .toLowerCase()
                            .replace(/[\s\t\n\r]+/g, '')
                            .replace(/[Â·ãƒ»'â€™"â€œâ€ã€‚ï¼Œã€:ï¼š;ï¼›!ï¼?ï¼Ÿ~ï½\-â€”_]/g, '')
                            .replace(/[ï¼ˆï¼‰()ã€ã€‘\[\]ã€Šã€‹<>]/g, '')
                            .replace(/[ã€Œã€ã€ã€]/g, '')
                            .replace(/çš„/g, '')
                            .replace(/ç¬¬[0-9ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒ]+[å­£æœŸéƒ¨]/g, '')
                            .replace(/(?:season|s)\d+/g, '');
                    };

                    const makeVariants = (str) => {
                        if (!str) return [];
                        const raw = String(str);
                        const removedBracketContent = raw.replace(/[ï¼ˆ(ã€\[].*?[ï¼‰)ã€‘\]]/g, '');
                        const removedRegion = raw
                            .replace(/ï¼ˆ[^ï¼‰]*æ¸¯æ¾³å°[^ï¼‰]*ï¼‰/g, '')
                            .replace(/\([^)]*æ¸¯æ¾³å°[^)]*\)/g, '');

                        const variants = new Set([
                            normalizeBasic(raw),
                            normalizeBasic(removedBracketContent),
                            normalizeBasic(removedRegion),
                        ]);
                        return Array.from(variants).filter(v => v && v.length >= 2);
                    };

                    const longestCommonSubstringLen = (a, b) => {
                        if (!a || !b) return 0;
                        const n = a.length;
                        const m = b.length;
                        if (!n || !m) return 0;

                        let maxLen = 0;
                        const dp = new Array(m + 1).fill(0);
                        for (let i = 1; i <= n; i++) {
                            let prev = 0;
                            for (let j = 1; j <= m; j++) {
                                const temp = dp[j];
                                if (a[i - 1] === b[j - 1]) {
                                    dp[j] = prev + 1;
                                    if (dp[j] > maxLen) maxLen = dp[j];
                                } else {
                                    dp[j] = 0;
                                }
                                prev = temp;
                            }
                        }
                        return maxLen;
                    };

                    const targets = makeVariants(name);
                    if (targets.length === 0) return;

                    let best = null;
                    let bestScore = 0;

                    for (const a of pool) {
                        const titleVariants = makeVariants(a && a.ç‰‡å);
                        const aliasVariants = makeVariants(a && a.åˆ«å);
                        const candidates = [...titleVariants, ...aliasVariants];
                        if (candidates.length === 0) continue;

                        let score = 0;
                        for (const t of targets) {
                            for (const c of candidates) {
                                if (c === t) {
                                    score = Math.max(score, 100);
                                    continue;
                                }
                                if (c.length >= 4 && t.includes(c)) {
                                    score = Math.max(score, 78 + Math.min(12, Math.round((c.length / t.length) * 12)));
                                }
                                if (t.length >= 4 && c.includes(t)) {
                                    score = Math.max(score, 78 + Math.min(12, Math.round((t.length / c.length) * 12)));
                                }
                                const lcs = longestCommonSubstringLen(t, c);
                                if (lcs >= 4) {
                                    score = Math.max(score, 64 + Math.min(30, lcs * 4));
                                }
                            }
                        }

                        if (score > bestScore) {
                            bestScore = score;
                            best = a;
                            if (bestScore >= 100) break;
                        }
                    }

                    if (best && bestScore >= 86) {
                        openDetail(best);
                        return;
                    }

                    if (calendarFuse) {
                        const queries = [name, ...targets];
                        let bestItem = null;
                        let bestFuseScore = Infinity;
                        let bestLcs = 0;

                        const scoreOf = (res) => (res && typeof res.score === 'number' ? res.score : Infinity);
                        const lcsOf = (item) => {
                            const title = normalizeBasic(item && item.ç‰‡å);
                            const alias = normalizeBasic(item && item.åˆ«å);
                            let max = 0;
                            for (const t of targets) {
                                if (title) max = Math.max(max, longestCommonSubstringLen(t, title));
                                if (alias) max = Math.max(max, longestCommonSubstringLen(t, alias));
                            }
                            return max;
                        };

                        for (const q of queries) {
                            const results = calendarFuse.search(q).slice(0, 6);
                            for (const r of results) {
                                const item = r && r.item;
                                if (!item) continue;
                                const lcs = lcsOf(item);
                                const s = scoreOf(r);

                                if (lcs > bestLcs || (lcs === bestLcs && s < bestFuseScore)) {
                                    bestLcs = lcs;
                                    bestFuseScore = s;
                                    bestItem = item;
                                }
                            }
                        }

                        if (bestItem && (bestFuseScore <= 0.18 || (bestLcs >= 3 && bestFuseScore <= 0.55))) {
                            openDetail(bestItem);
                            return;
                        }
                    }

                    searchQuery.value = name;
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                };


                const weekDays = ['å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­', 'å‘¨æ—¥'];
                const currentDayIndex = ref(new Date().getDay() === 0 ? 6 : new Date().getDay() - 1);
                
                const calendarGrouped = computed(() => {
                    const groups = {};
                    weekDays.forEach(day => groups[day] = []);
                    calendarData.forEach(item => {
                        if (groups[item.day]) {
                            groups[item.day].push(item);
                        }
                    });
                    Object.keys(groups).forEach(day => {
                        groups[day].sort((a, b) => {
                             if (!a.time) return 1;
                             if (!b.time) return -1;
                             return a.time.localeCompare(b.time);
                        });
                    });
                    return groups;
                });

                const loading = ref(true);
                const searchQuery = ref('');
                const selectedAnime = ref(null);
                const currentEpisodeUrl = ref(null);
                const currentSeason = ref('all');
                const currentStatus = ref('all'); // 'all', 'ongoing', 'completed'
                const currentGenre = ref('all');
                const hlsInstance = ref(null);
                const hlsVideoPrepared = ref(false);
                let videoUxTeardown = null;

                // é¢å¤–çŠ¶æ€
                const activeTab = ref('episodes');
                const relatedList = ref([]);
                const currentView = ref('list'); // 'list' | 'archive'
                const currentYear = new Date().getFullYear();
                const prevYear = currentYear - 1;
                let fuse = null;
                let calendarFuse = null;
                
                // åˆ†é¡µ
                const currentPage = ref(1);
                const pageSize = ref(24);

                // æœç´¢å»ºè®®
                const showSuggestions = ref(false);
                const searchSuggestions = computed(() => {
                    if (!searchQuery.value || !fuse) return [];
                    const results = fuse.search(searchQuery.value);
                    return results.slice(0, 8).map(r => r.item);
                });

                const selectSuggestion = (anime) => {
                    searchQuery.value = anime.ç‰‡å;
                    showSuggestions.value = false;
                };

                const getCurrentEpisodePosition = () => {
                    const anime = selectedAnime.value;
                    const url = currentEpisodeUrl.value;
                    if (!anime || !url) return null;
                    const currentUrl = typeof url === 'string' ? url.trim() : url;

                    const sources = Array.isArray(anime.æ’­æ”¾åœ°å€) ? anime.æ’­æ”¾åœ°å€ : [];
                    for (let sourceIndex = 0; sourceIndex < sources.length; sourceIndex++) {
                        const source = sources[sourceIndex];
                        const episodes = Array.isArray(source?.episodes) ? source.episodes : [];
                        for (let episodeIndex = 0; episodeIndex < episodes.length; episodeIndex++) {
                            const ep = episodes[episodeIndex];
                            const epUrl = typeof ep?.url === 'string' ? ep.url.trim() : ep?.url;
                            if (epUrl === currentUrl) return { sourceIndex, episodeIndex };
                        }
                    }
                    return null;
                };

                const playNextEpisode = () => {
                    const pos = getCurrentEpisodePosition();
                    if (!pos) return;
                    const sources = Array.isArray(selectedAnime.value?.æ’­æ”¾åœ°å€) ? selectedAnime.value.æ’­æ”¾åœ°å€ : [];
                    const episodes = Array.isArray(sources[pos.sourceIndex]?.episodes) ? sources[pos.sourceIndex].episodes : [];
                    const next = episodes[pos.episodeIndex + 1];
                    if (!next?.url) return;
                    playEpisode(next.url, next.name);
                };

                const ensureAutoNextBound = (video) => {
                    if (!video) return;
                    if (video.dataset.autoNextBound === '1') return;
                    video.dataset.autoNextBound = '1';
                    let triggeredForUrl = null;
                    const trigger = () => {
                        const url = currentEpisodeUrl.value;
                        if (!url) return;
                        if (triggeredForUrl === url) return;
                        triggeredForUrl = url;
                        playNextEpisode();
                    };
                    video.addEventListener('ended', () => {
                        trigger();
                    });
                    video.addEventListener('timeupdate', () => {
                        if (video.seeking) return;
                        const duration = video.duration;
                        if (!Number.isFinite(duration) || duration <= 0) return;
                        if (video.paused) return;
                        if (duration - video.currentTime > 0.35) return;
                        trigger();
                    });
                };

                const isTimeBuffered = (mediaEl, time) => {
                    try {
                        const buffered = mediaEl.buffered;
                        for (let i = 0; i < buffered.length; i++) {
                            if (time >= buffered.start(i) && time <= buffered.end(i)) return true;
                        }
                    } catch (_) {}
                    return false;
                };

                const attachSeekPreview = (video, getHls) => {
                    const container = video?.parentElement;
                    if (!container) return () => {};

                    const existing = container.querySelector('canvas[data-seek-preview="1"]');
                    const canvas = existing || document.createElement('canvas');
                    if (!existing) {
                        canvas.dataset.seekPreview = '1';
                        canvas.className = 'absolute inset-0 w-full h-full pointer-events-none hidden';
                        container.appendChild(canvas);
                    }
                    const ctx = canvas.getContext('2d');
                    let seekToken = 0;
                    let shouldCapture = false;
                    let lastCapturedTime = null;

                    const hide = () => {
                        canvas.classList.add('hidden');
                    };
                    const show = () => {
                        canvas.classList.remove('hidden');
                    };

                    const capture = () => {
                        const w = video.videoWidth;
                        const h = video.videoHeight;
                        if (!w || !h || !ctx) return false;
                        if (canvas.width !== w) canvas.width = w;
                        if (canvas.height !== h) canvas.height = h;
                        ctx.drawImage(video, 0, 0, w, h);
                        lastCapturedTime = video.currentTime;
                        show();
                        return true;
                    };

                    const requestCapture = (token) => {
                        const attempt = () => {
                            if (token !== seekToken) return;
                            if (!capture()) return;
                            const hls = typeof getHls === 'function' ? getHls() : null;
                            if (hls && typeof hls.startLoad === 'function') {
                                try {
                                    hls.startLoad();
                                } catch (_) {}
                            }
                        };

                        if (typeof video.requestVideoFrameCallback === 'function') {
                            video.requestVideoFrameCallback(() => attempt());
                        } else {
                            setTimeout(attempt, 0);
                        }
                    };

                    const onSeeking = () => {
                        hide();
                        shouldCapture = !isTimeBuffered(video, video.currentTime);
                        seekToken++;
                    };

                    const onSeeked = () => {
                        if (!shouldCapture) return;
                        const token = seekToken;
                        requestCapture(token);
                    };

                    const onPlaying = () => hide();

                    const onTimeUpdate = () => {
                        if (canvas.classList.contains('hidden')) return;
                        if (lastCapturedTime == null) return;
                        if (!video.paused && Math.abs(video.currentTime - lastCapturedTime) > 0.15) hide();
                    };

                    const onEmptied = () => hide();

                    video.addEventListener('seeking', onSeeking);
                    video.addEventListener('seeked', onSeeked);
                    video.addEventListener('playing', onPlaying);
                    video.addEventListener('timeupdate', onTimeUpdate);
                    video.addEventListener('emptied', onEmptied);

                    return () => {
                        video.removeEventListener('seeking', onSeeking);
                        video.removeEventListener('seeked', onSeeked);
                        video.removeEventListener('playing', onPlaying);
                        video.removeEventListener('timeupdate', onTimeUpdate);
                        video.removeEventListener('emptied', onEmptied);
                        hide();
                        if (!existing) canvas.remove();
                    };
                };

                // é”®ç›˜æ§åˆ¶é€»è¾‘
                const setupKeyboardControls = () => {
                    let pressTimer = null;
                    let isSpeeding = false;
                    const LONG_PRESS_DELAY = 300; // ms

                    const showToast = (msg) => {
                        const container = document.querySelector('.aspect-video');
                        if (!container) return;
                        
                        // ç§»é™¤æ—§ toast
                        const old = container.querySelector('.seek-toast');
                        if (old) old.remove();

                        const toast = document.createElement('div');
                        toast.className = 'seek-toast';
                        toast.textContent = msg;
                        toast.style.cssText = `
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            background: rgba(0,0,0,0.6);
                            color: white;
                            padding: 8px 16px;
                            border-radius: 4px;
                            pointer-events: none;
                            z-index: 50;
                            font-size: 14px;
                            backdrop-filter: blur(2px);
                            transition: opacity 0.3s;
                        `;
                        container.appendChild(toast);
                        setTimeout(() => {
                            toast.style.opacity = '0';
                            setTimeout(() => toast.remove(), 300);
                        }, 800);
                    };
                    
                    const showSpeedToast = (show) => {
                        const container = document.querySelector('.aspect-video');
                        if (!container) return;
                        
                        let toast = container.querySelector('.speed-toast');
                        if (show) {
                            if (!toast) {
                                toast = document.createElement('div');
                                toast.className = 'speed-toast';
                                toast.innerHTML = '<span class="text-cyan-400">âš¡</span> 2x é€Ÿæ’­æ”¾ä¸­';
                                toast.style.cssText = `
                                    position: absolute;
                                    top: 20px;
                                    right: 20px;
                                    background: rgba(0,0,0,0.6);
                                    color: white;
                                    padding: 6px 12px;
                                    border-radius: 4px;
                                    pointer-events: none;
                                    z-index: 50;
                                    font-size: 12px;
                                    font-weight: bold;
                                    backdrop-filter: blur(2px);
                                `;
                                container.appendChild(toast);
                            }
                        } else {
                            if (toast) toast.remove();
                        }
                    };

                    const onKeyDown = (e) => {
                        const video = document.getElementById('videoPlayer');
                        if (!video) return;
                        // å…è®¸æš‚åœæ—¶æ“ä½œï¼Œä½†å¿½ç•¥éæ–¹å‘é”®
                        if (video.paused && !e.key.startsWith('Arrow')) return;
                        if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
                        
                        if (e.key === 'ArrowRight') {
                            e.stopPropagation();
                            e.preventDefault();
                            if (e.repeat) return;

                            pressTimer = setTimeout(() => {
                                isSpeeding = true;
                                video.playbackRate = 2.0;
                                // é•¿æŒ‰åŠ é€Ÿæ—¶ï¼Œå¦‚æœæ˜¯æš‚åœçŠ¶æ€ï¼Œå¼ºåˆ¶æ’­æ”¾
                                if (video.paused) {
                                    video.play().catch(() => {});
                                }
                                showSpeedToast(true);
                            }, LONG_PRESS_DELAY);
                        } else if (e.key === 'ArrowLeft') {
                            e.stopPropagation();
                            e.preventDefault();
                            // é˜²æ­¢é•¿æŒ‰è¿ç»­è§¦å‘å¯¼è‡´å›é€€è¿‡å¿«
                            if (e.repeat) return;
                            video.currentTime = Math.max(0, video.currentTime - 5);
                            showToast('âª -5s');
                        }
                    };

                    const onKeyUp = (e) => {
                        const video = document.getElementById('videoPlayer');
                        if (!video) return;

                        if (e.key === 'ArrowRight') {
                            e.stopPropagation();
                            e.preventDefault();

                            if (pressTimer) {
                                clearTimeout(pressTimer);
                                pressTimer = null;
                            }

                            if (isSpeeding) {
                                isSpeeding = false;
                                video.playbackRate = 1.0;
                                showSpeedToast(false);
                            } else {
                                // çŸ­æŒ‰å¿«è¿› 5s
                                video.currentTime = Math.min(video.duration, video.currentTime + 5);
                                showToast('â© +5s');
                            }
                        }
                    };

                    window.addEventListener('keydown', onKeyDown, { capture: true });
                    window.addEventListener('keyup', onKeyUp, { capture: true });
                    
                    onUnmounted(() => {
                        window.removeEventListener('keydown', onKeyDown, { capture: true });
                        window.removeEventListener('keyup', onKeyUp, { capture: true });
                    });
                };

                // åŠ è½½æ•°æ®
                onMounted(async () => {
                    setupKeyboardControls();
                    try {
                        let response = await fetch('./metadata.json');
                        if (!response.ok) response = await fetch('../metadata.json');
                        if (!response.ok) throw new Error('Failed to load metadata');
                        animeList.value = await response.json();

                        try {
                            let movieResponse = await fetch('./japan_movies_metadata.json');
                            if (!movieResponse.ok) movieResponse = await fetch('../japan_movies_metadata.json');
                            if (movieResponse.ok) {
                                movieList.value = await movieResponse.json();
                            } else {
                                movieList.value = [];
                            }
                        } catch (_) {
                            movieList.value = [];
                        }

                        // New calendar data fetch
                        const calendarResponse = await fetch('./anime_calendar.json');
                        if (calendarResponse.ok) {
                            calendarData.value = await calendarResponse.json();
                        }

                        // åˆå§‹åŒ– Fuse
                        if (window.Fuse) {
                            const options = {
                                keys: ['ç‰‡å', 'åˆ«å', 'ç±»å‹', 'å¯¼æ¼”', 'ä¸»æ¼”', 'æ ‡ç­¾'],
                                threshold: 0.3,
                                includeScore: true
                            };
                            fuse = new Fuse(searchPool.value, options);

                            const calendarOptions = {
                                keys: ['ç‰‡å', 'åˆ«å'],
                                threshold: 0.45,
                                includeScore: true
                            };
                            calendarFuse = new Fuse(searchPool.value, calendarOptions);
                        }

                    } catch (error) {
                        console.error("Error loading anime data:", error);
                        alert("åŠ è½½æ•°æ®å¤±è´¥");
                    } finally {
                        loading.value = false;
                    }
                });

                // è®¡ç®—æ‰€æœ‰ç±»å‹
                const allGenres = computed(() => {
                    const ignoredGenres = new Set([
                        'åŠ¨ç”»', 'æ—¥æœ¬åŠ¨æ¼«', 'åŠ¨æ¼«', 'æ—¥æœ¬', 'å…¶å®ƒ', 'å…¶ä»–', 'null', 'undefined',
                        'å‚²å¨‡æ¶å½¹å¤§å°å§è‰æ³½æ´›ç‰¹ä¸å®å†µè½¬æ’­è¿œè—¤å›å’Œè§£è¯´å‘˜å°æ—',
                        'æ¥è‡ªå¼‚ä¸–ç•Œçš„é€ƒäº¡è€…',
                        'ä¸–ç•Œè§¦å‘è€…',
                        'è¶…è‡ªç„¶9äººç»„',
                        'æƒ…è‰²'
                    ]);
                    const termCount = new Map();
                    
                    animeList.value.forEach(anime => {
                        const perAnimeTerms = new Set();
                        const genres = (anime.ç±»å‹ || '').split(/[\/,ï¼Œ\sã€]+/).filter(Boolean);
                        const tags = (anime.TAGæ ‡ç­¾ || '').split(/[\/,ï¼Œ\sã€]+/).filter(Boolean);
                        
                        [...genres, ...tags].forEach(g => {
                            const trimmed = g.trim();
                            if (trimmed && !ignoredGenres.has(trimmed)) {
                                perAnimeTerms.add(trimmed);
                            }
                        });

                        perAnimeTerms.forEach(term => {
                            termCount.set(term, (termCount.get(term) || 0) + 1);
                        });
                    });
                    return Array.from(termCount.entries())
                        .filter(([, count]) => count > 1)
                        .sort((a, b) => b[1] - a[1] || a[0].localeCompare(b[0], 'zh-CN'))
                        .map(([term]) => term);
                });

                const genreExpanded = ref(false);
                const genrePreviewCount = 18;
                const displayedGenres = computed(() => {
                    return genreExpanded.value ? allGenres.value : allGenres.value.slice(0, genrePreviewCount);
                });

                // è®¡ç®—å­£åº¦
                const sortedSeasons = computed(() => {
                    const seasonMap = new Set();
                    animeList.value.forEach(anime => {
                        const dateStr = anime.é¦–æ’­æ—¶é—´ || '';
                        // å°è¯•è§£æ YYYY-MM
                        const match = dateStr.match(/^(\d{4})-(\d{2})/);
                        if (match) {
                            const year = parseInt(match[1]);
                            const month = parseInt(match[2]);
                            let seasonMonth = 1;
                            if (month >= 10) seasonMonth = 10;
                            else if (month >= 7) seasonMonth = 7;
                            else if (month >= 4) seasonMonth = 4;
                            else seasonMonth = 1;
                            
                            seasonMap.add(`${year}-${seasonMonth}`);
                        }
                    });

                    // å€’åºæ’åº
                    return Array.from(seasonMap).sort((a, b) => {
                        const [y1, m1] = a.split('-').map(Number);
                        const [y2, m2] = b.split('-').map(Number);
                        if (y1 !== y2) return y2 - y1;
                        return m2 - m1;
                    }).map(key => {
                        const [y, m] = key.split('-');
                        const monthNames = { '1': 'ä¸€', '4': 'å››', '7': 'ä¸ƒ', '10': 'å' };
                        return {
                            key: key,
                            label: `${y}å¹´${monthNames[m]}æœˆæ–°ç•ª`
                        };
                    });
                });

                // è®¡ç®—å­£åº¦åˆ†ç»„ï¼ˆæŒ‰å¹´ä»½ï¼‰
                const groupedSeasons = computed(() => {
                    const groups = {};
                    sortedSeasons.value.forEach(season => {
                        const [year, month] = season.key.split('-');
                        if (!groups[year]) {
                            groups[year] = [];
                        }
                        groups[year].push({
                            key: season.key,
                            label: `${month}æœˆ`,
                            fullLabel: season.label
                        });
                    });
                    
                    // æŒ‰å¹´ä»½å€’åº
                    return Object.keys(groups).sort((a, b) => b - a).map(year => ({
                        year: year,
                        seasons: groups[year] // sortedSeasons å·²ç»æ˜¯å€’åºçš„ï¼Œæ‰€ä»¥è¿™é‡Œæ˜¯ 10, 7, 4, 1
                    }));
                });

                const seasonKeySet = computed(() => new Set(sortedSeasons.value.map(s => s.key)));
                const seasonNavYear = ref('');
                const seasonNavYears = computed(() => groupedSeasons.value.map(g => g.year));

                const yearExpanded = ref(false);
                const yearPreviewCount = 18;
                const displayedYears = computed(() => {
                    return yearExpanded.value ? seasonNavYears.value : seasonNavYears.value.slice(0, yearPreviewCount);
                });

                watch(groupedSeasons, (groups) => {
                    if (!groups || groups.length === 0) return;
                    if (!seasonNavYear.value) {
                        seasonNavYear.value = 'all';
                    }
                }, { immediate: true });

                watch(currentSeason, (val) => {
                    if (val && val !== 'all') {
                        const [y] = val.split('-');
                        seasonNavYear.value = y;
                    } else if (val === 'all') {
                        seasonNavYear.value = 'all';
                    }
                });

                const seasonNavQuarters = computed(() => {
                    if (seasonNavYear.value === 'all') return [];
                    const year = seasonNavYear.value || groupedSeasons.value?.[0]?.year;
                    if (!year) return [];
                    const quarters = [
                        { m: 1, label: '1æœˆ' },
                        { m: 4, label: '4æœˆ' },
                        { m: 7, label: '7æœˆ' },
                        { m: 10, label: '10æœˆ' }
                    ];
                    const keys = seasonKeySet.value;
                    return quarters.map(q => {
                        const key = `${year}-${q.m}`;
                        return { key, label: q.label, enabled: keys.has(key) };
                    });
                });

                const setSeasonNavYear = (year) => {
                    seasonNavYear.value = year;
                };

                // è¿‡æ»¤é€»è¾‘
                const filteredAnimeList = computed(() => {
                    if (searchQuery.value) {
                        let results = [];
                        if (fuse) {
                            results = fuse.search(searchQuery.value).map(r => r.item);
                        } else {
                            const q = searchQuery.value.toLowerCase();
                            const pool = searchPool.value || [];
                            results = pool.filter(anime => {
                                const title = (anime.ç‰‡å || '').toLowerCase();
                                const alias = (anime.åˆ«å || '').toLowerCase();
                                return title.includes(q) || alias.includes(q);
                            });
                        }

                        if (currentStatus.value !== 'all') {
                            results = results.filter(anime => {
                                const isCompleted = (anime.çŠ¶æ€ || '').includes('å®Œç»“');
                                return currentStatus.value === 'completed' ? isCompleted : !isCompleted;
                            });
                        }

                        if (currentGenre.value !== 'all') {
                            results = results.filter(anime => {
                                const g = currentGenre.value;
                                const typeText = anime.ç±»å‹ || '';
                                const tagText = anime.TAGæ ‡ç­¾ || '';
                                return typeText.includes(g) || tagText.includes(g);
                            });
                        }

                        if (currentSeason.value !== 'all') {
                            results = results.filter(anime => {
                                const dateStr = anime.é¦–æ’­æ—¶é—´ || '';
                                if (!dateStr) return true;
                                if (currentSeason.value.indexOf('-') === -1) {
                                    const sYear = parseInt(currentSeason.value);
                                    const match = dateStr.match(/^(\d{4})/);
                                    return match && parseInt(match[1]) === sYear;
                                }
                                const [sYear, sMonth] = currentSeason.value.split('-').map(Number);
                                const match = dateStr.match(/^(\d{4})-(\d{2})/);
                                if (!match) return false;
                                const year = parseInt(match[1]);
                                const month = parseInt(match[2]);
                                if (year !== sYear) return false;
                                let quarter = 1;
                                if (month >= 10) quarter = 10;
                                else if (month >= 7) quarter = 7;
                                else if (month >= 4) quarter = 4;
                                return quarter === sMonth;
                            });
                        }

                        return results;
                    }

                    let list = animeList.value;

                    // 1. å­£åº¦ç­›é€‰
                    if (currentSeason.value !== 'all') {
                        if (currentSeason.value.indexOf('-') === -1) {
                            // ä»…å¹´ä»½ç­›é€‰
                            const sYear = parseInt(currentSeason.value);
                            list = list.filter(anime => {
                                const dateStr = anime.é¦–æ’­æ—¶é—´ || '';
                                const match = dateStr.match(/^(\d{4})/);
                                return match && parseInt(match[1]) === sYear;
                            });
                        } else {
                            // å¹´ä»½+å­£åº¦ç­›é€‰
                            const [sYear, sMonth] = currentSeason.value.split('-').map(Number);
                            list = list.filter(anime => {
                                const dateStr = anime.é¦–æ’­æ—¶é—´ || '';
                                const match = dateStr.match(/^(\d{4})-(\d{2})/);
                                if (!match) return false;
                                
                                const year = parseInt(match[1]);
                                const month = parseInt(match[2]);
                                
                                if (year !== sYear) return false;
                                
                                // è®¡ç®—å­£åº¦
                                let quarter = 1;
                                if (month >= 10) quarter = 10;
                                else if (month >= 7) quarter = 7;
                                else if (month >= 4) quarter = 4;
                                
                                return quarter === sMonth;
                            });
                        }
                    }

                    // 1.5 çŠ¶æ€ç­›é€‰
                    if (currentStatus.value !== 'all') {
                        list = list.filter(anime => {
                            const isCompleted = (anime.çŠ¶æ€ || '').includes('å®Œç»“');
                            return currentStatus.value === 'completed' ? isCompleted : !isCompleted;
                        });
                    }

                    // 1.8 ç±»å‹ç­›é€‰
                    if (currentGenre.value !== 'all') {
                        list = list.filter(anime => {
                            const g = currentGenre.value;
                            const typeText = anime.ç±»å‹ || '';
                            const tagText = anime.TAGæ ‡ç­¾ || '';
                            return typeText.includes(g) || tagText.includes(g);
                        });
                    }

                    return list;
                });

                // åˆ†é¡µé€»è¾‘
                const totalPages = computed(() => Math.ceil(filteredAnimeList.value.length / pageSize.value));
                
                const paginatedAnimeList = computed(() => {
                    const start = (currentPage.value - 1) * pageSize.value;
                    const end = start + pageSize.value;
                    return filteredAnimeList.value.slice(start, end);
                });

                const changePage = (page) => {
                    if (page < 1 || page > totalPages.value) return;
                    currentPage.value = page;
                    window.scrollTo({ top: 0, behavior: 'smooth' });
                };

                // ç›‘å¬ç­›é€‰æ¡ä»¶å˜åŒ–å¹¶é‡ç½®åˆ†é¡µ
                watch([currentSeason, searchQuery], () => {
                    currentPage.value = 1;
                    if (searchQuery.value) {
                        currentView.value = 'list';
                    }
                });

                const filterSeason = (key) => {
                    currentSeason.value = key;
                    currentView.value = 'list';
                };

                const goHome = () => {
                    currentSeason.value = 'all';
                    currentStatus.value = 'all';
                    currentGenre.value = 'all';
                    seasonNavYear.value = 'all';
                    currentView.value = 'list';
                };

                const getSeasonLabel = (key) => {
                    if (key && key !== 'all' && key.indexOf('-') === -1) {
                        return `${key}å¹´æ–°ç•ª`;
                    }
                    const found = sortedSeasons.value.find(s => s.key === key);
                    return found ? found.label : key;
                };

                const isNew = (dateStr) => {
                    if (!dateStr) return false;
                    const now = new Date();
                    const date = new Date(dateStr);
                    const diffTime = Math.abs(now - date);
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                    return diffDays < 90; // å°äº 3 ä¸ªæœˆ
                };

                // æ¨èé€»è¾‘
                const generateRecommendations = (target) => {
                   if (!target) return [];
                   
                   const getTerms = (str) => str ? str.split(/[\/,ï¼Œ\sã€]+/).filter(Boolean) : [];
                   
                   const targetGenres = getTerms(target.ç±»å‹);
                   const targetDirector = getTerms(target.å¯¼æ¼”);
                   const targetActors = getTerms(target.ä¸»æ¼” || target.æ¼”å‘˜);
                   
                   // æƒé‡
                   const W_GENRE = 2;
                   const W_DIRECTOR = 3;
                   const W_ACTOR = 1;
                   const W_RATING = 0.5;
                   
                   const pool = searchPool.value || [];
                   const candidates = pool.filter(a => a !== target).map(a => {
                       let score = 0;
                       
                       // ç±»å‹é‡åˆ
                       const aGenres = getTerms(a.ç±»å‹);
                       const commonGenres = targetGenres.filter(g => aGenres.includes(g));
                       score += commonGenres.length * W_GENRE;
                       
                       // å¯¼æ¼”é‡åˆ
                       const aDirector = getTerms(a.å¯¼æ¼”);
                       if (targetDirector.some(d => aDirector.includes(d))) score += W_DIRECTOR;
                       
                       // ä¸»æ¼”é‡åˆ
                       const aActors = getTerms(a.ä¸»æ¼” || a.æ¼”å‘˜);
                       const commonActors = targetActors.filter(act => aActors.includes(act));
                       score += commonActors.length * W_ACTOR;
                       
                       // è¯„åˆ†åŠ æƒ
                       const rating = parseFloat(a.è±†ç“£) || 0;
                       score += rating * W_RATING;
                       
                       return { item: a, score };
                   });
                   
                   return candidates.sort((a, b) => b.score - a.score).slice(0, 10).map(c => c.item);
                };

                // è¯¦æƒ…ä¸æ’­æ”¾å™¨
                const openDetail = (anime) => {
                    selectedAnime.value = anime;
                    currentEpisodeUrl.value = null;
                    activeTab.value = 'episodes';
                    document.body.style.overflow = 'hidden';
                    relatedList.value = generateRecommendations(anime);
                };

                const closeDetail = () => {
                    selectedAnime.value = null;
                    currentEpisodeUrl.value = null;
                    document.body.style.overflow = '';
                    if (videoUxTeardown) {
                        videoUxTeardown();
                        videoUxTeardown = null;
                    }
                    if (hlsInstance.value) {
                        hlsInstance.value.destroy();
                        hlsInstance.value = null;
                    }
                    const video = document.getElementById('videoPlayer');
                    if (video) {
                        video.pause();
                        video.removeAttribute('src');
                        video.load();
                    }
                };

                const playEpisode = (url, name) => {
                    currentEpisodeUrl.value = url;
                    
                    nextTick(() => {
                        const video = document.getElementById('videoPlayer');
                        if (!video) return;
                        ensureAutoNextBound(video);

                        if (window.Hls && Hls.isSupported()) {
                            if (videoUxTeardown) {
                                videoUxTeardown();
                                videoUxTeardown = null;
                            }
                            if (hlsInstance.value) {
                                hlsInstance.value.destroy();
                                hlsInstance.value = null;
                                hlsVideoPrepared.value = false;
                            }

                            const prepareVideo = () => {
                                if (hlsVideoPrepared.value) return;
                                hlsVideoPrepared.value = true;
                                video.preload = 'auto';
                                video.playsInline = true;
                            };

                            const getOrCreateHls = () => {
                                if (hlsInstance.value) return hlsInstance.value;
                                const hls = new Hls({
                                    enableWorker: true,
                                    lowLatencyMode: false,
                                    capLevelToPlayerSize: true,
                                    backBufferLength: 90,
                                    maxBufferHole: 2.0,
                                    maxBufferLength: 120,
                                    maxMaxBufferLength: 600,
                                    startFragPrefetch: true,
                                    fragLoadingTimeOut: 20000,
                                    manifestLoadingTimeOut: 20000,
                                    levelLoadingTimeOut: 20000,
                                    fragLoadingMaxRetry: 6,
                                    manifestLoadingMaxRetry: 6,
                                    levelLoadingMaxRetry: 6,
                                    fragLoadingRetryDelay: 1000,
                                    manifestLoadingRetryDelay: 1000,
                                    levelLoadingRetryDelay: 1000,
                                });
                                hls.on(Hls.Events.ERROR, (_event, data) => {
                                    if (!data || !data.fatal) return;
                                    if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {
                                        try {
                                            hls.startLoad();
                                        } catch (_) {}
                                        return;
                                    }
                                    if (data.type === Hls.ErrorTypes.MEDIA_ERROR) {
                                        try {
                                            hls.recoverMediaError();
                                        } catch (_) {}
                                        return;
                                    }
                                    try {
                                        hls.destroy();
                                    } finally {
                                        hlsInstance.value = null;
                                        hlsVideoPrepared.value = false;
                                    }
                                });
                                hlsInstance.value = hls;
                                return hls;
                            };

                            prepareVideo();

                            const hls = getOrCreateHls();
                            const onParsed = () => {
                                hls.off(Hls.Events.MANIFEST_PARSED, onParsed);
                                const p = video.play();
                                if (p && typeof p.catch === 'function') p.catch(() => {});
                            };
                            hls.on(Hls.Events.MANIFEST_PARSED, onParsed);

                            const setSource = () => {
                                hls.loadSource(url);
                            };
                            if (hls.media !== video) {
                                const onAttached = () => {
                                    hls.off(Hls.Events.MEDIA_ATTACHED, onAttached);
                                    setSource();
                                };
                                hls.on(Hls.Events.MEDIA_ATTACHED, onAttached);
                                hls.attachMedia(video);
                            } else {
                                setSource();
                            }

                            videoUxTeardown = attachSeekPreview(video, () => hls);
                        } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
                            if (videoUxTeardown) {
                                videoUxTeardown();
                                videoUxTeardown = null;
                            }
                            if (hlsInstance.value) {
                                hlsInstance.value.destroy();
                                hlsInstance.value = null;
                                hlsVideoPrepared.value = false;
                            }
                            video.src = url;
                            video.load();
                            video.addEventListener('loadedmetadata', () => {
                                const p = video.play();
                                if (p && typeof p.catch === 'function') p.catch(() => {});
                            }, { once: true });

                            videoUxTeardown = attachSeekPreview(video, null);
                        }
                    });
                };

                // å¯¼èˆªé«˜äº®é€»è¾‘
                const currentActiveNav = computed(() => {
                    if (currentView.value !== 'list') return currentView.value; // 'archive'

                    if (currentStatus.value === 'ongoing' && currentSeason.value === 'all') return 'ongoing';
                    if (currentStatus.value === 'completed' && currentSeason.value === 'all') return 'completed';
                    if (currentSeason.value === String(currentYear)) return 'currentYear';
                    if (currentSeason.value === String(prevYear)) return 'prevYear';
                    return 'home';
                });

                return {
                    loading,
                    searchQuery,
                    sortedSeasons,
                    groupedSeasons,     // å·²æ·»åŠ 
                    seasonNavYears,
                    seasonNavYear,
                    seasonNavQuarters,
                    setSeasonNavYear,
                    yearExpanded,
                    yearPreviewCount,
                    displayedYears,
                    currentSeason,
                    currentStatus,
                    currentGenre,
                    allGenres,
                    genreExpanded,
                    genrePreviewCount,
                    displayedGenres,
                    filteredAnimeList,
                    paginatedAnimeList, // å·²æ·»åŠ 
                    currentPage,        // å·²æ·»åŠ 
                    currentView,        // è§†å›¾æ¨¡å¼
                    showSuggestions,    // æœç´¢å»ºè®®
                    searchSuggestions,  // æœç´¢å»ºè®®
                    selectSuggestion,   // æœç´¢å»ºè®®
                    totalPages,         // å·²æ·»åŠ 
                    changePage,         // å·²æ·»åŠ 
                    activeTab,          // å·²æ·»åŠ 
                    relatedList,        // å·²æ·»åŠ 
                    filterSeason,
                    goHome,
                    getSeasonLabel,
                    selectedAnime,
                    openDetail,
                    closeDetail,
                    playEpisode,
                    currentEpisodeUrl,
                    isNew,
                    currentYear,
                    prevYear,
                    currentActiveNav,
                    weekDays,
                    currentDayIndex,
                    calendarGrouped,
                    calendarData,
                    currentDayAnime,
                    handleCalendarClick
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
